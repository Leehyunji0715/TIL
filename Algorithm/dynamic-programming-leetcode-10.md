#### [참고(공부한) 영상](https://www.youtube.com/watch?v=l3hda49XcDE)

## Leetcode [10번](https://leetcode.com/problems/regular-expression-matching/) 문제

## 문제 전략
- Dynamic Programming 이용

## 알고리즘
- 2차원 array를 만든다. <br/> 
문자열 길이를 m이라 하고, 정규식 길이를 n이라 한다면 arr[m][n] 으로 나타낸다. <br/> 현재를 나타내는 index를 arr[i][j]라고 가정.
- (0) 빈 문자열에 대한 빈 정규식은 match 가 된 것이다. 따라서 true다.
- (1) 만약 현재 체크하는 문자가 현재 체크하는 정규식 문자와 일치할 때, 바로 이전 문자까지도 이전 정규식 문자까지 matching되면 현재 체크하는 문자도 matching 된 것이므로 true다. (arr[i][j] = arr[i-1][j-1] ==> 여기서 DP 사용된 것이다. 이전까지 누적된 정규식 Matching 결과를 바로 사용한 것이므로)
- (2) '.'는 만능 문자로, 어떠한 문자에 대해서도 match가 된 것으로 간주할 수 있다.
    - (1)때와 마찬가지로 matching된 것으로 간주하고 같은 동작을 한다.
- (3) "\*"는 바로 앞에 있는 문자를 0번 이상 나타낼 수 있는 글자이다.
'ca*b'에서 "a*"이 되므로 "cb"도 가능하고 "caaaaab"도 가능하다.
    - 0개일 때: arr[i][j-2]의 값을 확인한다. 만약 해당 값이 True이면, 현재 arr[i][j]값도 True이다. 왜냐하면 preceding 문자가 아얘 없다고 할 때 (0개 일 때) Matching된거라고 보면 되기 때문.
    - 1개 이상일 때: 만약 해당 arr[i][j-2]가 False이면, 여기서 preceding 문자가 있을 때는 Matching이 될 수 있는건가? 라고 생각할 수 있다. <br/>
    arr[i][j-1]가 preceding 문자를 나타낸다는 것을 기억하자. <br/>
    현재 체크하는 문자가 arr[i][j-1]이랑 같은 문자인지 먼저 확인하고, arr[i-1][j]가 true면 true이다. 왜냐하면 arr[i-1][j]는 이전에도 preceding 문자가 0번 이상 쓰일 때도 true가 된 것이기 때문인데, "\*"이기 떄문에 현재 쓰여도 true이기 때문이다.


### 개인 노트
 - "*" 에서 문제에서 말하는 preceding이 바로 앞에 있는 글자가 아닌 앞에 있는 모든 글자를 포함하는 줄 알았다...(실수)
 - 경우의 수를 따지는 문제들은 DP를 쓰면 효율적이고 간단하개 풀어낼 수 있는 것 같다.
 - DP를 공부하려 풀기로 한 문제였는데 결국 도움을 청하게 된 문제... <br/>정규식을 제대로 써본적이 없어서 그런지 문제 이해도가 낮았던 것 같다. 지금이라도 알아서 다행이고, 많은 것을 배우고 실습하는 중요성을 알았다.
